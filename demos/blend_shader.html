<link rel="stylesheet" href="../styles.css">
<script type="module">
  import * as THREE from '../lib/three.module.js';
  import { ThreeDemo } from './src/ThreeDemo.js';

  import * as ShaderChunks from './src/ShaderChunks.js';

  const cols = 6, rows = 6;
  const tileMap = [
    0, 0, 0, 1, 1, 1,
    0, 1, 1, 1, 1, 0,
    0, 1, 0, 1, 0, 0,
    0, 1, 1, 1, 0, 0,
    1, 0, 0, 0, 1, 1,
    1, 0, 0, 0, 1, 1, 
  ];

  //
  // Geometry
  //

  const positions = [];
  const uvs = [];
  const indices = [];
  
  let index = 0;
  for ( let row = 0; row < rows - 1; row ++ ) {
    for ( let col = 0; col < cols - 1; col ++ ) {
      // Flipping the UV so my images will be right-side-up
      positions.push( col + 1, 0, row     );  uvs.push( 1, 0 );
      positions.push( col,     0, row     );  uvs.push( 0, 0 );
      positions.push( col + 1, 0, row + 1 );  uvs.push( 1, 1 );
      positions.push( col,     0, row + 1 );  uvs.push( 0, 1 );
      indices.push( index,     index + 1, index + 2 );
      indices.push( index + 2, index + 1, index + 3 );
      index += 4;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
  geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( uvs, 2 ) );
  geometry.setIndex( indices );

  const tileIndices = [];

  for ( let row = 0; row < rows - 1; row ++ ) {
    for ( let col = 0; col < cols - 1; col ++ ) {
      const wCol = Math.max(0, col), eCol = Math.min(col + 1, cols - 1);
      const nRow = Math.max(0, row), sRow = Math.min(row + 1, rows - 1);

      const nw = tileMap[ wCol + nRow * cols ];
      const ne = tileMap[ eCol + nRow * cols ];
      const sw = tileMap[ wCol + sRow * cols ];
      const se = tileMap[ eCol + sRow * cols ];

      for ( let i = 0; i < 4; i ++ ) {
        tileIndices.push( nw, ne, sw, se );
      }
    }
  }

  geometry.setAttribute( 'tileIndex',  new THREE.Int32BufferAttribute( tileIndices, 4 ));

  // Sand (smooth): step 0.4-0.6, noise 0.25, 2, 1
  // Dirt (grainy): step 0.25-0.75, noise 0.35, 35, 1
  
  const dirt = getBlendShader( 0 );
  const grass = getBlendShader( 1 );
  const grid = new THREE.MeshBasicMaterial({ wireframe: true, color: 'yellow', visible: false });

  const loader = new THREE.TextureLoader();
  loader.load('./textures/dirt_tileable.png', function( texture ) { 
    dirt.uniforms.diffuse.value = texture;
    dirt.needsUpdate = true;
    demo.render();
  });
  loader.load('./textures/grass_tileable.png', function( texture ) { 
    grass.uniforms.diffuse.value = texture;
    grass.needsUpdate = true;
    demo.render();
  });


  geometry.clearGroups();
  geometry.addGroup( 0, Infinity, 0 );
  geometry.addGroup( 0, Infinity, 1 );
  geometry.addGroup( 0, Infinity, 2 );

  const mesh = new THREE.Mesh( geometry, [ dirt, grass, grid ] );

  const centerX = (cols - 1) / 2;
  const centerZ = (rows - 1) / 2;

  const demo = new ThreeDemo();
  demo.scene.add( mesh );
  demo.camera.position.set( 0, 4, 4 );
  demo.camera.position.set( centerX, 3, centerZ * 3 );
  demo.controls.target.set( centerX, 0, centerZ * 1.5 );
  demo.controls.update();
  demo.render();

  for ( let u in grass.uniforms ) {
    demo.addToGui( grass.uniforms[ u ] );
  }
  demo.gui.add( grid, 'visible' ).name( 'Show Grid' ).onChange( () => demo.render() );

  function getBlendShader(
    tileIndex,
    {
      minStep = 0.25, maxStep = 0.75,
      noiseAmp = 0.2, noiseFreq = 10, noiseOffset = 1,
    } = {} 
  ) {
    return new THREE.ShaderMaterial({
      uniforms: {
        diffuse: { value: null, showInGUI: false },
        currentTileIndex: { value: tileIndex, showInGUI: false },
        minStep: { value: minStep, min: 0, max: 1, name: 'Min Step' },
        maxStep: { value: maxStep, min: 0, max: 1, name: 'Max Step' },
        noiseAmp: { value: noiseAmp, min: 0, max: 1, name: 'Noise Amp' },
        noiseFreq: { value: noiseFreq, min: 0, max: 40, name: 'Noise Freq' },
        noiseOffset: { value: noiseOffset, min: 0, max: 10, name: 'Noise Offset' },
      },
      vertexShader: `
        in ivec4 tileIndex;
        
        out vec2 v_uv;
        out vec3 v_pos;
        flat out ivec4 f_tileIndex;
        
        void main() {
          v_uv = uv;
          v_pos = position;
          f_tileIndex = tileIndex;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        // TODO: Do we want higher precision for anything?

        ${ ShaderChunks.Noise3D }

        uniform sampler2D diffuse;
        uniform int currentTileIndex;

        uniform float minStep, maxStep;
        uniform float noiseAmp, noiseFreq, noiseOffset;

        in vec2 v_uv;
        in vec3 v_pos;
        flat in ivec4 f_tileIndex;
        
        out vec4 outColor;

        const vec2 NW = vec2( 0.0, 0.0 );
        const vec2 NE = vec2( 1.0, 0.0 );
        const vec2 SW = vec2( 0.0, 1.0 );
        const vec2 SE = vec2( 1.0, 1.0 );

        const float N = 0.0;
        const float W = 0.0;
        const float E = 1.0;
        const float S = 1.0;

        float blend2() {
        	// NW, NE, SW, SE
          vec4 corners = vec4( greaterThanEqual( f_tileIndex, ivec4( currentTileIndex ) ) );

          // N, W, E, S
          vec4 edges = corners.xxyz * corners.yzww;

          float nw = corners.x * distance( v_uv, NW );
          float ne = corners.y * distance( v_uv, NE );
          float sw = corners.z * distance( v_uv, SW );
          float se = corners.w * distance( v_uv, SE );

          float n = edges.x * distance( v_uv.y, N );
          float w = edges.y * distance( v_uv.x, W );
          float e = edges.z * distance( v_uv.x, E );
          float s = edges.w * distance( v_uv.x, S );

          // TODO: Still working on this one...
          return 0.0;
        }

        float simpleBlend() {
          // NW, NE, SW, SE
          vec4 corners = vec4( greaterThanEqual( f_tileIndex, ivec4( currentTileIndex ) ) );
          float noise = noiseAmp * snoise( noiseFreq * v_pos + noiseOffset );

          vec2 horiz = mix( corners.xz, corners.yw, smoothstep( minStep, maxStep, v_uv.x + noise ) );
          return mix( horiz.x, horiz.y, smoothstep( minStep, maxStep, v_uv.y + noise ) );
        }

        void main() {
          outColor = vec4( texture2D( diffuse, v_uv ).rgb, simpleBlend() );
        }
      `,
      glslVersion: THREE.GLSL3,
      transparent: true,
    });
  }

</script>
