<link rel="stylesheet" href="../styles.css">
<script type="module">
  import * as THREE from '../lib/three.module.js';
  import { ThreeDemo } from './src/ThreeDemo.js';

  import * as ShaderChunks from './src/ShaderChunks.js';

  //
  // Geometry
  //

  const geometry = new THREE.PlaneBufferGeometry( 1, 1, 20, 20 );
  geometry.clearGroups();
  geometry.addGroup( 0, Infinity, 0 );
  geometry.addGroup( 0, Infinity, 1 );
  
  const shader = getShader();
  const grid = new THREE.MeshBasicMaterial({ wireframe: true, color: 'yellow', visible: false });

  const mesh = new THREE.Mesh( geometry, [ shader, grid ] );

  const demo = new ThreeDemo();
  demo.scene.add( mesh );

  //demo.render();

  for ( let u in shader.uniforms ) {
    demo.addToGui( shader.uniforms[ u ] );
  }
  demo.gui.add( grid, 'visible' ).name( 'Show Grid' ).onChange( () => demo.render() );
  //demo.gui.close();

  function getShader() {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_noise: {
          value: { amplitude: 0.25, frequency: 1, offset: 1 }
        },
        D: { value: 0.0001 },
        lightPos: { value: new THREE.Vector3( 0, 0, 1 ) },
      },
      vertexShader: `
        ${ ShaderChunks.OctaveNoise }

        uniform NoiseParams u_noise;

        out vec2 v_uv;
        out vec3 v_pos;
        
        void main() {
          v_uv = uv;

          v_pos = position;
          v_pos.z = octaveNoise( v_pos, u_noise );

          gl_Position = projectionMatrix * modelViewMatrix * vec4( v_pos, 1.0 );
        }
      `,
      fragmentShader: `
        ${ ShaderChunks.OctaveNoise }

        uniform NoiseParams u_noise;
        uniform vec3 lightPos;

        uniform float D;

        in vec2 v_uv;
        in vec3 v_pos;
        
        out vec3 outColor;

        void main() {
          float L = octaveNoise( vec3( v_pos.x - D, v_pos.y, 0.0 ), u_noise );
          float R = octaveNoise( vec3( v_pos.x + D, v_pos.y, 0.0 ), u_noise );
          float T = octaveNoise( vec3( v_pos.x, v_pos.y - D, 0.0 ), u_noise );
          float B = octaveNoise( vec3( v_pos.x, v_pos.y + D, 0.0 ), u_noise );

          vec3 norm = vec3( ( R - L ) / ( 2.0 * D ), ( B - T ) / ( 2.0 * D ), 1.0 );
          norm = normalize( norm );

          vec3 lightColor = vec3( 1.0, 1.0, 1.0 );

          vec3 lightDir = normalize( lightPos - v_pos );
          float diff = max( dot( norm, lightDir ), 0.0 );
          vec3 diffuse = diff * lightColor;

          outColor = diffuse * vec3( 0.4, 0.2, 0.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    });
  }

</script>
