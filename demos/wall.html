<link rel="stylesheet" href="../styles.css">
<script type="module">
  import * as THREE from '../lib/three.module.js';
  import { ThreeDemo } from './src/ThreeDemo.js';

  import * as ShaderChunks from './src/ShaderChunks.js';

  //
  // Geometry
  //

  const geometry = new THREE.PlaneBufferGeometry( 1, 1, 20, 20 );
  geometry.clearGroups();
  geometry.addGroup( 0, Infinity, 0 );
  geometry.addGroup( 0, Infinity, 1 );
  
  const shader = getShader();
  const grid = new THREE.MeshBasicMaterial({ wireframe: true, color: 'yellow', visible: false });

  const mesh = new THREE.Mesh( geometry, [ shader, grid ] );

  const demo = new ThreeDemo();
  demo.scene.add( mesh );

  //demo.controls.autoRotate = true;
  //demo.controls.autoRotateSpeed = 0.5;
  //demo.render();

  for ( let u in shader.uniforms ) {
    demo.addToGui( shader.uniforms[ u ] );
  }
  demo.gui.add( grid, 'visible' ).name( 'Show Grid' ).onChange( () => demo.render() );
  //demo.gui.close();

  function getShader() {
    return new THREE.ShaderMaterial({
      uniforms: {
        u_noise: {
          value: { amplitude: 0.1, frequency: 1, offset: 1 }
        }
      },
      vertexShader: `
        ${ ShaderChunks.OctaveNoise }

        uniform NoiseParams u_noise;

        out vec2 v_uv;
        out vec3 v_norm;
        out vec3 v_pos;
        
        void main() {
          v_uv = uv;


          const float D = 0.1;
          float C = octaveNoise( position, u_noise );
          float L = octaveNoise( position + vec3( -D,  0,  0 ), u_noise );
          float R = octaveNoise( position + vec3(  D,  0,  0 ), u_noise );
          float T = octaveNoise( position + vec3(  0, -D,  0 ), u_noise );
          float B = octaveNoise( position + vec3(  0,  D,  0 ), u_noise );

          v_pos = position;
          v_pos.z = C;

          v_norm = vec3( ( R - L ) / ( 2.0 * D ), ( B - T ) / ( 2.0 * D ), 1.0 );
          //v_norm = normalize( v_norm );
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4( v_pos, 1.0 );
        }
      `,
      fragmentShader: `
        ${ ShaderChunks.OctaveNoise }

        uniform NoiseParams u_noise;

        in vec2 v_uv;
        in vec3 v_pos;
        in vec3 v_norm;
        
        out vec3 outColor;

        void main() {

          vec3 norm = normalize( v_norm );

          vec3 lightPos = vec3( 0.0, 0.0, 1.0 );
          vec3 lightColor = vec3( 1.0, 1.0, 1.0 );

          vec3 lightDir = normalize( lightPos - v_pos );
          float diff = max( dot( norm, lightDir ), 0.0 );
          vec3 diffuse = diff * lightColor;

          outColor = diffuse;  //vec3( octaveNoise( v_pos, u_noise ) / u_noise.amplitude );
        }
      `,
      glslVersion: THREE.GLSL3,
    });
  }

</script>
