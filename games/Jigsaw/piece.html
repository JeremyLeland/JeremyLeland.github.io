<style>
  .shadow {
    /* filter: drop-shadow( 10px 10px black ); */
  }
  .piece {
    position: absolute;
    /* background-image: url(https://asset.bloomnation.com/c_pad,d_vendor:global:catalog:product:image.png,f_auto,fl_preserve_transparency,q_auto/v1605326787/vendor/364/catalog/product/s/h/shutterstock_90055534_30.jpg);
    width: 150px;
    height: 150px; */
  }
  svg {
    fill: none;
    stroke: black;
  }
</style>

<body>
  <svg>
    <path id='curves'></path>
  </svg>
</body>

<script>

  // Someday, try to make this look like: https://freesvg.org/img/jigsaw6x8.png

  const curves = getCurvesThroughPoints( [
    [ 100, 100 ], [ 140, 110 ], [ 135, 90 ], [ 150, 75 ], [ 165, 90 ], [ 160, 110 ],
    [ 200, 100 ], [ 240, 110 ], [ 235, 90 ], [ 250, 75 ], [ 265, 90 ], [ 260, 110 ],
    [ 300, 100 ]
  ], 0.75 );

  document.getElementById( 'curves' ).setAttribute( 'd', 'M' + curves.join(' ') );

  const shadows = document.createElement( 'div' );
  shadows.className = 'shadow';
  document.body.appendChild( shadows );

  const image = '';

  // NOTE: Array looks like:
  //   N
  //  W E
  //   S 
  const cols = 3, rows = 3;
  const offsets = [
      [  25, 25 ],
    [ -25, 25, -25 ],
      [ -25, -25 ],
    [ -25, 25, 25 ],
      [  25, -25 ],
  ];

  // TODO: Specify long rows and columns of curves, pick from these to create pieces?

  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {

      const top = row == 0 ? 0 : offsets[ row * 2 - 1 ][ col ];
      const left = col == 0 ? 0 : offsets[ row * 2 ][ col - 1 ];
      const right = col == cols - 1 ? 0 : offsets[ row * 2 ][ col ];
      const bottom = row == rows - 1 ? 0 : offsets[ row * 2 + 1 ][ col ];

      const north =  top == 0 ? 'l 100,0' : `l  40,0 c -10,${ top } 30,${ top } 20,0 l 40,0`;
      const east = right == 0 ? 'l 0,100' : `l  0,40 c ${ right },-10 ${ right },30 0,20 l 0,40`;
      const south = bottom == 0 ? 'l -100,0' : `l -40,0 c 10,${ bottom } -30,${ bottom } -20,0 l -40,0`;
      const west = left == 0 ? 'l 0,-100' : `l   0,-40 c ${ left },10 ${ left },-30 0,-20 l 0,-40`;

      const path = `M ${ col * 100 },${ row * 100 } ${ north } ${ east } ${ south } ${ west }`;

      // https://thumbs.dreamstime.com/b/frangipani-flowers-10997030.jpg
      const piece = document.createElement( 'img' );
      piece.className = 'piece';
      piece.src = 'https://asset.bloomnation.com/c_pad,d_vendor:global:catalog:product:image.png,f_auto,fl_preserve_transparency,q_auto/v1605326787/vendor/364/catalog/product/s/h/shutterstock_90055534_30.jpg'
      piece.style.clipPath = `path(' ${ path } ')`;
      //piece.style.backgroundPositionX = `${ -col * 100 }px`;
      //piece.style.backgroundPositionY = `${ -row * 100 }px`;
      piece.style.transform = `translate( ${ col * 25 }px, ${ row * 25 }px )`;
      shadows.appendChild( piece );
    }
  }

  // See http://csharphelper.com/blog/2019/04/draw-a-smooth-curve-in-wpf-and-c/
  function getCurvesThroughPoints( points, tension = 0.5 ) {
    const control_scale = tension / 0.5 * 0.175;

    const curves = [];
    curves.push( points[ 0 ].join( ',' ) );

    for ( let i = 0; i < points.length - 1; i ++ )
    {
      const pt_before = points[ Math.max( i - 1, 0 ) ];
      const pt = points[ i ];
      const pt_after = points[ i + 1 ];
      const pt_after2 = points[ Math.min( i + 2, points.length - 1 ) ];

      const p2 = [ 
        pt[ 0 ] + control_scale * ( pt_after[ 0 ] - pt_before[ 0 ] ), 
        pt[ 1 ] + control_scale * ( pt_after[ 1 ] - pt_before[ 1 ] ) 
      ];
      const p3 = [ 
        pt_after[ 0 ] - control_scale * ( pt_after2[ 0 ] - pt[ 0 ] ), 
        pt_after[ 1 ] - control_scale * ( pt_after2[ 1 ] - pt[ 1 ] )
      ];

      curves.push( `C ${ p2.join( ',' ) } ${ p3.join( ',' ) } ${ pt_after.join( ',' ) }` );
    }

    return curves;
  }


</script>