<title>Tetravex SVG</title>
<style>
  body {
    background-color: black;
    user-select: none;
    overflow: hidden;
    margin: 0;
  }

  /* TODO: aspect-ratio is not supported on Safari/iOS */
  /* Would something like this work instead? http://jsfiddle.net/webtiki/MpXYr/3/ */
  /* Probably need to choose height or width and accomodate that */

  /* #wrapper {
    aspect-ratio: 1 / 2.4;
    max-width: 100%;
    width: auto;
    height: 100%;
    margin: 8px;
    position: relative;
  } */
  /* .block {
    position: absolute;
  } */
  text {
    fill: white;
    font-family: sans-serif;
  }

  .grid {
    width: 100%;
    /* padding-bottom: 100%; */
    position: relative;
    stroke: white;
    stroke-width: 2;
  }
  polygon { stroke: black; stroke-width: 2px; }

  /* Colors */
  .color0 { fill: red }
  .color1 { fill: orange }
  .color2 { fill: yellow }
  .color3 { fill: chartreuse }
  .color4 { fill: blue }
  .color5 { fill: deepskyblue }
  .color6 { fill: darkviolet }
  .color7 { fill: hotpink }
  .color8 { fill: dimgray }
</style>

<body>
  <svg id="wrapper" viewBox="0 0 100 230" style="width: 100%; height: 100%" preserveAspectRatio="xMinYMin">
    <svg id="solution" stroke="white" stroke-width="2"></svg>

    <text id="title" x="0" y="115" style="font-weight: bold;">Tetravex</text>
    <text id="subtitle" x="0" y="125" style="font-size: 45%;">Arrange tiles so colors match</text>

    <svg id="shuffled" y="130" stroke="white" stroke-width="2"></svg>
  </svg>
</body>

<script>
  const XMLNS = 'http://www.w3.org/2000/svg';
  const POINTS = [
    '0,0 50,50 100,0',      // north
    '0,0 50,50, 0,100',     // west
    '100,0 50,50 100,100',  // east
    '0,100 50,50 100,100'   // south
  ];

  const cols = 3, rows = 3;
  const COLORS = 9;

  const wrapper = document.getElementById( 'wrapper' );
  const solutionGrid = document.getElementById( 'solution' );
  const shuffledGrid = document.getElementById( 'shuffled' );

  prepareGrid( solutionGrid, cols, rows );
  prepareGrid( shuffledGrid, cols, rows );
  generateSolution( cols, rows );

  let active = null;

  // mouseDown handled by the block we clicked on
  document.onmousemove = mouseMove;
  document.onmouseup = mouseUp;

  function prepareGrid( grid, cols, rows ) {
    grid.blocks = Array( cols * rows );

    const size = Math.floor( 100 / cols );

    for ( let col = 0; col <= cols; col ++ ) {
      const line = document.createElementNS( XMLNS, 'line' );
      line.setAttribute( 'x1', `${ col * size }` );
      line.setAttribute( 'y1', `${ 0   * size }` );
      line.setAttribute( 'x2', `${ col  * size }` );
      line.setAttribute( 'y2', `${ rows * size }` );
      line.setAttribute( 'vector-effect', 'non-scaling-stroke' );
      grid.appendChild( line );
    }

    for ( let row = 0; row <= rows; row ++ ) {
      const line = document.createElementNS( XMLNS, 'line' );
      line.setAttribute( 'x1', `${ 0   * size }` );
      line.setAttribute( 'y1', `${ row * size }` );
      line.setAttribute( 'x2', `${ cols * size }` );
      line.setAttribute( 'y2', `${ row  * size }` );
      line.setAttribute( 'vector-effect', 'non-scaling-stroke' );
      grid.appendChild( line );
    }
  }

  /**
   * Blocks
   */
  function createBlock( { north, west, east, south } ) {
    const block = document.createElementNS( XMLNS, 'svg' );
    block.setAttribute( 'class', 'block' );
    block.setAttribute( 'viewBox', '0 0 100 100' );
    block.setAttribute( 'preserveAspectRatio', 'xMidYMin' );

    block.setAttribute( 'width',  `${ 100 / cols }%` );

    block.north = north;
    block.west = west;
    block.east = east;
    block.south = south;

    block.onmousedown = mouseDown;

    // TODO: Would path be easier/cleaner in any way?
    dom = [];
    [ north, west, east, south ].forEach( ( color, index ) => {
      const polygon =  document.createElementNS( XMLNS, 'polygon' );
      polygon.setAttribute( 'points', POINTS[ index ] );
      polygon.setAttribute( 'class', `color${ color }` );
      block.appendChild( polygon );

      dom[ index ] = polygon;
    } );

    return block;
  }

  function placeInGrid( block, col, row, grid ) {
    grid.appendChild( block );

    block.setAttribute( 'x', ( 1 / cols ) * col * 100 );
    block.setAttribute( 'y', ( 1 / rows ) * row * 100 );

    grid.blocks[ col + row * cols ] = block;
    block.grid = grid;
    block.col = col;
    block.row = row;
  }
  
  function tryAlignToGrid( block, x, y, grid ) {
    const sb = grid.getBoundingClientRect();
    if ( sb.left <= x && x <= sb.right && sb.top <= y && y <= sb.bottom ) {
      const col = Math.floor( cols * ( x - sb.left ) / sb.width  );
      const row = Math.floor( rows * ( y - sb.top )  / sb.height );

      const existingBlock = grid.blocks[ col + row * cols ];
      if ( existingBlock ) {
        grid.removeChild( existingBlock );  // so we don't double-add here
        placeInGrid( existingBlock, block.col, block.row, block.grid );
      }

      placeInGrid( block, col, row, grid );

      return true;
    }
    else {
      return false;
    }
  }

  function isValidSolution( blocks ) {
    for ( let index = 0, row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++, index ++ ) {
        const block = blocks[ index ];

        if ( !block )   return false;

        if ( 0 < row && block.north != blocks[ index - cols ]?.south )   return false;
        if ( 0 < col && block.west != blocks[ index - 1 ]?.east )        return false;
        if ( col < cols - 1 && block.east  != blocks[ index + 1]?.west )       return false;
        if ( row < rows - 1 && block.south != blocks[ index + cols ]?.north )  return false;
      }
    }

    return true;
  }

  /**
   * Input
   */

  function pickUpBlock( block, x, y ) {
    const bounds = block.getBoundingClientRect();

    active = {
      block: block,
      offsetX: x - bounds.x,
      offsetY: y - bounds.y,
    };

    block.grid.removeChild( block );
    block.grid.blocks[ block.col + block.row * cols ] = null;

    wrapper.appendChild( block );

    block.style.zIndex = 2;

    setActiveBlockLocation( x, y );
  }

  function setActiveBlockLocation( x, y ) {
    if ( active ) {
      const wrapperBox = wrapper.viewBox.baseVal;

      // NOTE: Because Safari needs wrapper to have width and height of 100%, I can't use wrapper.clientWidth/Height
      //       Base this on shuffledGrid bottom right corner instead as a workaround
      const shuffledBounds = shuffledGrid.getBoundingClientRect();
      active.block.setAttribute( 'x', wrapperBox.width * ( x - active.offsetX ) / shuffledBounds.right );
      active.block.setAttribute( 'y', wrapperBox.height * ( y - active.offsetY ) / shuffledBounds.bottom );
    }
  }

  function releaseActiveBlock( x, y ) {
    if ( active ) {
      wrapper.removeChild( active.block );

      if ( !tryAlignToGrid( active.block, x, y, solutionGrid ) ) {
        if ( !tryAlignToGrid( active.block, x, y, shuffledGrid ) ) {
          placeInGrid( active.block, active.block.col, active.block.row, active.block.grid );
        }
      }

      active.block.style.zIndex = 1;

      active = null;

      if ( isValidSolution( solutionGrid.blocks ) ) {
        // TODO: Change title to "Solved!" and description to "click for next game"
        console.log( 'Valid solution!' );
      }
    }
  }
  
  function mouseDown( e ) {
    pickUpBlock( e.currentTarget, e.offsetX, e.offsetY );
  }

  function mouseMove( e ) {
    setActiveBlockLocation( e.offsetX, e.offsetY );
  }

  function mouseUp( e ) {
    releaseActiveBlock( e.offsetX, e.offsetY );
  }

  function generateSolution( cols, rows ) {

    // NOTE: Array looks like:
    //   N
    //  W E
    //   S 
    const values = Array.from( Array( rows * 2 + 1 ), ( ( _, index ) => 
                    Array.from( Array( cols + ( index % 2 ) ), _ => 
                      Math.floor( Math.random() * COLORS ) ) ) );
    

    const blocks = [];
    for ( let row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++ ) {
        blocks.push( createBlock( {
          north: values[ row * 2 ][ col ],
          west: values[ row * 2 + 1 ][ col ],
          east: values[ row * 2 + 1 ][ col + 1 ],
          south: values[ row * 2 + 2 ][ col ]
        } ) );
      }
    }

    for ( let row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++ ) {
        const block = blocks.splice( Math.floor( Math.random() * blocks.length ), 1 )[ 0 ];
        wrapper.appendChild( block );
        placeInGrid( block, col, row, shuffledGrid );
      }
    }
  }

</script>