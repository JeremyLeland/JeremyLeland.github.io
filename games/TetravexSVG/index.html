<style>
  body {
    background-color: black;
    color: white;
    user-select: none;
    overflow: hidden;
  }
  h3 {
    font: bold 30px sans-serif;
    margin: 0;
  }
  p  { font: bold 20px sans-serif }
  .block {
    position: absolute;
    width: 64px;
    height: 64px;
  }

  .grid {
    background-image: linear-gradient(   0deg, white 1px, transparent 1px ), 
                      linear-gradient(  90deg, white 1px, transparent 1px ),
                      linear-gradient( 180deg, white 1px, transparent 1px ),
                      linear-gradient( 270deg, white 1px, transparent 1px );
    background-size: 64px 64px;
  }
  polygon { stroke: black; stroke-width: 2px; }
  .color0 { fill: red }
  .color1 { fill: orange }
  .color2 { fill: yellow }
  .color3 { fill: chartreuse }
  .color4 { fill: blue }
  .color5 { fill: deepskyblue }
  .color6 { fill: darkviolet }
  .color7 { fill: hotpink }
  .color8 { fill: dimgray }
</style>

<body>
  <!-- TODO: Don't hardcode width/height here -->
  <!-- Maybe SVG with lines instead of CSS linear-gradient hack? -->
  <div id="solution" class="grid" style="width: 192; height: 192"></div>

  <!-- TODO: Text formatting -- center title at least? -->
  <h3>Tetravex</h3>
  <span>Arrange tiles so colors match</span>
  <div id="shuffled" class="grid" style="width: 192; height: 192"></div>
</body>

<script>
  const XMLNS = 'http://www.w3.org/2000/svg';
  const POINTS = [
    '0,0 50,50 100,0',      // north
    '0,0 50,50, 0,100',     // west
    '100,0 50,50 100,100',  // east
    '0,100 50,50 100,100'   // south
  ];

  // TODO: See if we can avoid size, since it may depend on screen size.
  //       Can we use cols/rows to figure out where we are in grid?
  const size = 64;
  const cols = 3, rows = 3;

  const grids = [];
  [ 'solution', 'shuffled' ].forEach( id => {
    grids[ id ] = document.getElementById( id );
    grids[ id ].blocks = Array( cols * rows );
  } );

  /**
   * Blocks
   */
  // TODO: Get rid of Block class, make constructor a normal function that makes SVG dom
  class Block {
    constructor( { north, west, east, south } ) {
      this.svg = document.createElementNS( XMLNS, 'svg' );
      this.svg.setAttribute( 'class', 'block' );
      this.svg.setAttribute( 'viewBox', '0 0 100 100' );

      this.svg.north = north;
      this.svg.west = west;
      this.svg.east = east;
      this.svg.south = south;

      this.svg.onmousedown = mouseDown;
      this.svg.onmousemove = mouseMove;
      this.svg.onmouseup   = mouseUp;

      // TODO: Would path be easier/cleaner in any way?
      this.dom = [];
      [ north, west, east, south ].forEach( ( color, index ) => {
        const polygon =  document.createElementNS( XMLNS, 'polygon' );
        polygon.setAttribute( 'points', POINTS[ index ] );
        polygon.setAttribute( 'class', `color${ color }` );
        this.svg.appendChild( polygon );

        this.dom[ index ] = polygon;
      } );
    }
  }

  function setLocation( block, x, y ) {
    block.style.left = x;
    block.style.top  = y;
  }

  function placeInGrid( block, col, row, grid ) {
    const sb = grid.getBoundingClientRect();
    setLocation( block, sb.left + col * size, sb.top + row * size );

    grid.blocks[ col + row * cols ] = block;
    block.grid = grid;
    block.col = col;
    block.row = row;
  }
  
  function tryAlignToGrid( block, x, y, grid ) {
    const sb = grid.getBoundingClientRect();
    if ( sb.left <= x && x <= sb.right && sb.top <= y && y <= sb.bottom ) {
      const col = Math.floor( ( x - sb.left ) / size );
      const row = Math.floor( ( y - sb.top )  / size );

      const existingBlock = grid.blocks[ col + row * cols ];
      if ( existingBlock ) {
        placeInGrid( existingBlock, block.col, block.row, block.grid );
      }

      placeInGrid( block, col, row, grid );

      return true;
    }
    else {
      return false;
    }
  }

  function isValidSolution( blocks ) {
    for ( let index = 0, row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++, index ++ ) {
        const block = blocks[ index ];

        if ( !block )   return false;

        if ( 0 < row && block.north != blocks[ index - cols ]?.south )   return false;
        if ( 0 < col && block.west != blocks[ index - 1 ]?.east )        return false;
        if ( col < cols - 1 && block.east  != blocks[ index + 1]?.west )       return false;
        if ( row < rows - 1 && block.south != blocks[ index + cols ]?.north )  return false;
      }
    }

    return true;
  }

  /**
   * Input
   */
  let active = null;

  function mouseDown( e ) {
    const block = e.currentTarget;

    active = {
      block: block,
      offsetX: e.offsetX,
      offsetY: e.offsetY,
    };

    block.grid.blocks[ block.col + block.row * cols ] = null;

    block.style.zIndex = 2;
  }

  // TODO: Sometimes this misses if mouse goes outside bounds, should we attach this elsewhere?
  function mouseMove( e ) {
    if ( active ) {
      setLocation( active.block, e.pageX - active.offsetX, e.pageY - active.offsetY );
    }
  }

  function mouseUp( e ) {
    const x = e.pageX, y = e.pageY;

    if ( !tryAlignToGrid( active.block, x, y, grids[ 'solution' ] ) ) {
      if ( !tryAlignToGrid( active.block, x, y, grids[ 'shuffled' ] ) ) {
        placeInGrid( active.block, active.block.col, active.block.row, active.block.grid );
      }
    }

    active.block.style.zIndex = 1;

    active = null;

    if ( isValidSolution( grids[ 'solution' ].blocks ) ) {
      // TODO: Change title to "Solved!" and description to "click for next game"
      console.log( 'Valid solution!' );
    }
  }

  function generateSolution( cols, rows ) {

    // NOTE: Array looks like:
    //   N
    //  W E
    //   S 
    const values = Array.from( Array( rows * 2 + 1 ), ( ( _, index ) => 
                    Array.from( Array( cols + ( index % 2 ) ), _ => 
                      Math.floor( Math.random() * 8 ) ) ) )

    for ( let row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++ ) {
        const block = new Block( {
          north: values[ row * 2 ][ col ],
          west: values[ row * 2 + 1 ][ col ],
          east: values[ row * 2 + 1 ][ col + 1 ],
          south: values[ row * 2 + 2 ][ col ]
        } );

        placeInGrid( block.svg, col, row, grids[ 'shuffled' ] );
        document.body.appendChild( block.svg )
      }
    }
  }

  generateSolution( cols, rows );

  // const blockStyle = document.styleSheets[0].cssRules[0].style;
  // blockStyle.width = size;
  // blockStyle.height = size;

</script>
