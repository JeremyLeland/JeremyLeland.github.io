<style>
  body { margin: 0 }
</style>

<body>
  <canvas id="canvas"></canvas>
</body>

<script>
  const canvas = document.getElementById( 'canvas' );
  window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.onresize();

  const ctx = canvas.getContext( '2d' );

  class Snake {
    #x;
    #y;
    #angle = 0;
    #size = 10;
    #speed = 0.2;
    #turnSpeed = 0.005;
    #tail = [];
    #length = 0;

    goalAngle = 0;
    color = `hsl( ${ Math.random() * 360 }deg, 50%, 50% )`;
    maxLength = 100;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
    }

    angleTo( other ) { return this.angleToPoint( other.#x, other.#y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.#y, x - this.#x ); }

    distanceTo( other ) { return this.distanceToPoint( other.#x, other.#y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.#x, y - this.#y ); }

    update( dt, others ) {
      this.draw( ctx );

      // let angX = mouseX - this.#x;
      // let angY = mouseY - this.#y;
      let angX = 0, angY = 0;

      const DESIRED_SEPARATION = this.#size * 4;

      //ctx.beginPath();
      others.forEach( other => {
        const dist = other.distanceTo( this );

        if ( dist < DESIRED_SEPARATION ) {
          // Divide by dist once to normalize
          // Divide by dist again to give greater weight to closer others
          const cx = ( this.#x - other.#x ) / dist / dist;
          const cy = ( this.#y - other.#y ) / dist / dist;

          // ctx.beginPath();
          // ctx.moveTo( this.#x, this.#y );
          // ctx.lineTo( this.#x + cx, this.#y + cy );
          // ctx.strokeStyle = other.color;
          // ctx.lineWidth = 2;
          // ctx.stroke();

          angX += cx;
          angY += cy;
        }
      } );
      // ctx.strokeStyle = 'blue';
      // ctx.lineWidth = 4;
      // ctx.stroke();

      if ( angX == 0 && angY == 0 ) {
        angX = mouseX - this.#x;
        angY = mouseY - this.#y;
      }
      // else {
      //   ctx.beginPath();
      //   ctx.moveTo( this.#x, this.#y );
      //   ctx.lineTo( this.#x + angX, this.#y + angY );
      //   ctx.strokeStyle = 'red';
      //   ctx.lineWidth = 4;
      //   ctx.stroke();
      // }

      this.goalAngle = Math.atan2( angY, angX );

      this.#turnTowardGoal( dt );

      const moveDist = this.#speed * dt;

      this.#tail.push( { x: this.#x, y: this.#y, angle: this.#angle, length: moveDist } );
      this.#length += moveDist;

      while ( this.#length > this.maxLength ) {
        this.#length -= this.#tail.shift().length;
      }

      this.#x += Math.cos( this.#angle ) * moveDist;
      this.#y += Math.sin( this.#angle ) * moveDist;
    }

    #turnTowardGoal( dt ) {
      // Fix internal angle to better match goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    draw( ctx ) {
      const leftCoords = [], rightCoords = [];
      for ( let i = 0; i < this.#tail.length; i ++ ) {
        const width = this.#size * i / this.#tail.length;

        const leftAng = this.#tail[ i ].angle - Math.PI / 2;
        const leftX = this.#tail[ i ].x + Math.cos( leftAng ) * width;
        const leftY = this.#tail[ i ].y + Math.sin( leftAng ) * width;
        leftCoords.push( { x: leftX, y: leftY } );

        const rightAng = this.#tail[ i ].angle + Math.PI / 2;
        const rightX = this.#tail[ i ].x + Math.cos( rightAng ) * width;
        const rightY = this.#tail[ i ].y + Math.sin( rightAng ) * width;
        rightCoords.unshift( { x: rightX, y: rightY } );
      }

      ctx.beginPath();
      ctx.arc( this.#x, this.#y, this.#size, this.#angle - Math.PI / 2, this.#angle + Math.PI / 2 );
      rightCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      leftCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      ctx.closePath();

      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  const snakes = Array.from( Array( 10 ), _ => 
    new Snake( Math.random() * canvas.width, Math.random() * canvas.height ) 
  );

  let mouseX = 0, mouseY = 0;
  document.onmousemove = onInput;
  document.ontouchstart = onInput;
  document.ontouchmove = onInput;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.pageX;
    mouseY = event.pageY;
  }

  function update( dt ) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height );

    snakes.forEach( snake => 
      snake.update( dt, snakes.filter( e => e != snake ) )
    );
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>