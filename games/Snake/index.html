<style>
  body { margin: 0 }
</style>

<body>
  <canvas id="canvas"></canvas>
</body>

<script>
  const canvas = document.getElementById( 'canvas' );
  window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.onresize();

  const ctx = canvas.getContext( '2d' );

  class Snake {
    #x;
    #y;
    #angle = 0;
    #size = 10;
    #speed = 0.2;
    #turnSpeed = 0.005;
    #tail = [];

    goalAngle = 0;
    color = `hsl( ${ Math.random() * 360 }deg, 50%, 50% )`;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
    }

    angleTo( other ) { return this.angleToPoint( other.#x, other.#y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.#y, x - this.#x ); }

    distanceTo( other ) { return this.distanceToPoint( other.#x, other.#y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.#x, y - this.#y ); }

    update( dt, others ) {
      this.draw( ctx );

      let angX = mouseX - this.#x;
      let angY = mouseY - this.#y;

      const DESIRED_SEPARATION = this.#size * 4;

      ctx.beginPath();
      others.forEach( other => {
        const dist = other.distanceTo( this );

        if ( dist < DESIRED_SEPARATION ) {
          const cx = ( this.#x - other.#x ); // / dist;  // / dist;
          const cy = ( this.#y - other.#y ); // / dist;  // / dist;

          ctx.moveTo( this.#x, this.#y );
          ctx.lineTo( this.#x + cx, this.#y + cy );

          angX = cx;
          angY = cy;
        }
      } );
      ctx.strokeStyle = 'blue';
      ctx.stroke();

      this.goalAngle = Math.atan2( angY, angX );

      this.#turnTowardGoal( dt );

      if ( this.#tail.push( { x: this.#x, y: this.#y, angle: this.#angle } ) > 20 ) {
        this.#tail.shift();
      }

      this.#x += Math.cos( this.#angle ) * this.#speed * dt;
      this.#y += Math.sin( this.#angle ) * this.#speed * dt;

      // this.draw( ctx );
    }

    #turnTowardGoal( dt ) {
      // Fix internal angle to better match goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    draw( ctx ) {
      const leftCoords = [], rightCoords = [];
      for ( let i = 0; i < this.#tail.length; i ++ ) {
        const width = this.#size * i / this.#tail.length;

        const leftAng = this.#tail[ i ].angle - Math.PI / 2;
        const leftX = this.#tail[ i ].x + Math.cos( leftAng ) * width;
        const leftY = this.#tail[ i ].y + Math.sin( leftAng ) * width;
        leftCoords.push( { x: leftX, y: leftY } );

        const rightAng = this.#tail[ i ].angle + Math.PI / 2;
        const rightX = this.#tail[ i ].x + Math.cos( rightAng ) * width;
        const rightY = this.#tail[ i ].y + Math.sin( rightAng ) * width;
        rightCoords.unshift( { x: rightX, y: rightY } );
      }

      ctx.beginPath();
      ctx.arc( this.#x, this.#y, this.#size, this.#angle - Math.PI / 2, this.#angle + Math.PI / 2 );
      rightCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      leftCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      ctx.closePath();

      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.stroke();
    }
  }

  const snakes = Array.from( Array( 10 ), _ => 
    new Snake( Math.random() * 500, Math.random() * 500 ) 
  );

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
  }

  function update( dt ) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height );

    snakes.forEach( snake => 
      snake.update( dt, snakes.filter( e => e != snake ) )
    );
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>