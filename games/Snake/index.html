<style>
  body { margin: 0 }
</style>

<body>
  <canvas id="canvas" width="500" height="500"></canvas>
</body>

<script>
  const canvas = document.getElementById( 'canvas' );
  const ctx = canvas.getContext( '2d' );

  class Snake {
    #x;
    #y;
    #angle = 0;
    goalAngle = 0;
    #size = 10;
    #speed = 0.2;
    #turnSpeed = 0.005;
    #tail = [];
    #svg;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
    }

    angleTo( other ) { return angleToPoint( other.#x, other.#y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.#y, x - this.#x ); }

    distanceTo( other ) { return distanceTo( other.#x, other.#y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.#x, y - this.#y ); }

    update( dt ) {
      this.#updateAngle( dt );

      if ( this.#tail.push( { x: this.#x, y: this.#y, angle: this.#angle } ) > 20 ) {
        this.#tail.shift();
      }

      this.#x += Math.cos( this.#angle ) * this.#speed * dt;
      this.#y += Math.sin( this.#angle ) * this.#speed * dt;

      this.draw( ctx );
    }

    #updateAngle( dt ) {
      // Fix goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    draw( ctx ) {
      const leftCoords = [], rightCoords = [];
      for ( let i = 0; i < this.#tail.length; i ++ ) {
        const width = this.#size * i / this.#tail.length;

        const leftAng = this.#tail[ i ].angle - Math.PI / 2;
        const leftX = this.#tail[ i ].x + Math.cos( leftAng ) * width;
        const leftY = this.#tail[ i ].y + Math.sin( leftAng ) * width;
        leftCoords.push( { x: leftX, y: leftY } );

        const rightAng = this.#tail[ i ].angle + Math.PI / 2;
        const rightX = this.#tail[ i ].x + Math.cos( rightAng ) * width;
        const rightY = this.#tail[ i ].y + Math.sin( rightAng ) * width;
        rightCoords.unshift( { x: rightX, y: rightY } );
      }

      ctx.beginPath();
      ctx.arc( this.#x, this.#y, this.#size, this.#angle - Math.PI / 2, this.#angle + Math.PI / 2 );
      rightCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      leftCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      ctx.closePath();

      ctx.fillStyle = 'red';
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.stroke();
    }
  }

  const snakes = [
    new Snake( 32, 32 ),
    new Snake( 128, 128 ),
  ];

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
  }

  function update( dt ) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height );

    snakes.forEach( snake => {

      // const avoidAngle = snakes.filter( e => e != snake ).map( other => {
      //   const dist = other.distanceTo( snake );
      //   return [ 
      //     ( snake.x - other.x ) / dist, 
      //     ( snake.y - other.y ) / dist
      //   ];

      // }

      //   other.angleTo( snake ) / other.distanceTo( snake )
      // ).reduce

      snake.goalAngle = snake.angleToPoint( mouseX, mouseY );

      snake.update( dt );
    });
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>