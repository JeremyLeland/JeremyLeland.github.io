<style>
  body { margin: 0 }
</style>

<body>
  <canvas id="canvas"></canvas>
</body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script>
  const Settings = {
    GoalWeight: 0.5,
    AvoidWeight: 100,
    AvoidPower: 1,
    DrawForces: false,
  };

  const canvas = document.getElementById( 'canvas' );
  window.onresize = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.onresize();

  const ctx = canvas.getContext( '2d' );

  class Snake {
    #x;
    #y;
    #angle = 0;
    #size = 10;
    #turnSpeed = 0.005;
    #tail = [];
    #length = 0;

    #avoidVector;

    #isAlive = true;

    goalX = 0;
    goalY = 0;
    goalAngle = 0;
    speed = 0.2;

    color = `hsl( ${ Math.random() * 360 }deg, 50%, 50% )`;
    maxLength = 100;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
    }

    angleTo( other ) { return this.angleToPoint( other.#x, other.#y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.#y, x - this.#x ); }

    distanceTo( other ) { return this.distanceToPoint( other.#x, other.#y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.#x, y - this.#y ); }

    update( dt, others ) {
      this.draw( ctx );
      
      if ( this.#isAlive ) {
        const distToGoal = this.distanceToPoint( this.goalX, this.goalY );
        let angX = Settings.GoalWeight * ( this.goalX - this.#x ) / distToGoal;
        let angY = Settings.GoalWeight * ( this.goalY - this.#y ) / distToGoal;

        this.#compareAgainstOthers( others );

        if ( this.#isAlive ) {
          angX += this.#avoidVector.x;
          angY += this.#avoidVector.y;

          this.goalAngle = Math.atan2( angY, angX );

          this.#turnTowardGoal( dt );

          const moveDist = this.speed * dt;

          this.#tail.push( { x: this.#x, y: this.#y, angle: this.#angle, length: moveDist } );
          this.#length += moveDist;

          this.#x += Math.cos( this.#angle ) * moveDist;
          this.#y += Math.sin( this.#angle ) * moveDist;
        }
      }
      else {
        this.maxLength -= this.speed * dt;
      }

      while ( this.#length > this.maxLength && this.#tail.length > 0 ) {
        this.#length -= this.#tail.shift().length;
      }
    }

    // TODO: Not just others -- need to check against ourselves, too! (as we get longer)
    #compareAgainstOthers( others ) {
      const DESIRED_SEPARATION = this.#size * 2;

      let angX = 0, angY = 0;
      others.forEach( other => {
        let avoidX = 0, avoidY = 0;
        other.#tail.forEach( segment => {
          const dist = this.distanceToPoint( segment.x, segment.y );

          if ( dist < this.#size + other.#size ) {
            this.#isAlive = false;
            this.#avoidVector = { x: 0, y: 0 };
            return;
          }

          // TODO: Account for segment width
          // for ( let i = 0; i < this.#tail.length; i ++ ) {
          //   const width = this.#size * i / this.#tail.length;

          const avoidWeight = Math.abs( Settings.AvoidWeight / Math.pow( dist - DESIRED_SEPARATION, Settings.AvoidPower ) );

          const cx = avoidWeight * ( this.#x - segment.x ) / dist;
          const cy = avoidWeight * ( this.#y - segment.y ) / dist;

          avoidX += cx / other.#tail.length;
          avoidY += cy / other.#tail.length;

        } );

        angX += avoidX / others.length;
        angY += avoidY / others.length;

      } );

      this.#avoidVector = { x: angX, y: angY };
    }

    #turnTowardGoal( dt ) {
      // Fix internal angle to better match goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    draw( ctx ) {
      const leftCoords = [], rightCoords = [];
      for ( let i = 0; i < this.#tail.length; i ++ ) {
        const width = this.#size * i / this.#tail.length;

        const leftAng = this.#tail[ i ].angle - Math.PI / 2;
        const leftX = this.#tail[ i ].x + Math.cos( leftAng ) * width;
        const leftY = this.#tail[ i ].y + Math.sin( leftAng ) * width;
        leftCoords.push( { x: leftX, y: leftY } );

        const rightAng = this.#tail[ i ].angle + Math.PI / 2;
        const rightX = this.#tail[ i ].x + Math.cos( rightAng ) * width;
        const rightY = this.#tail[ i ].y + Math.sin( rightAng ) * width;
        rightCoords.unshift( { x: rightX, y: rightY } );
      }

      ctx.beginPath();
      ctx.arc( this.#x, this.#y, this.#size, this.#angle - Math.PI / 2, this.#angle + Math.PI / 2 );
      rightCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      leftCoords.forEach( coord => ctx.lineTo( coord.x, coord.y ) );
      ctx.closePath();

      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  const snakes = Array.from( Array( 20 ), _ => 
    new Snake( Math.random() * canvas.width, Math.random() * canvas.height ) 
  );

  // TEMP: Put a static obstacle to test against
  // const obstacle = new Snake( 100, 500 );
  // obstacle.goalX = 500;
  // obstacle.goalY = 500;
  // for ( let i = 0; i < 200; i ++ ) {
  //   obstacle.update( 10, snakes );
  // }
  // obstacle.speed = 0;

  // snakes.push( obstacle );

  const gui = new dat.GUI();
  gui.width = 200;
  for ( const setting in Settings ) {
    gui.add( Settings, setting );
  }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = onInput;
  document.ontouchstart = onInput;
  document.ontouchmove = onInput;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.pageX;
    mouseY = event.pageY;
  }

  let keyDown = true;     // default to running
  document.onkeydown = () => keyDown = true;
  document.onkeyup   = () => keyDown = false;

  function update( dt ) {
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height );

    snakes.forEach( snake => {
      snake.goalX = mouseX;
      snake.goalY = mouseY;
      snake.update( dt, snakes.filter( e => e != snake ) )
    } );
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only

    // Only update when key is pressed (for debugging purposes)
    if ( keyDown ) {
      update( now - lastTime );
    }
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>