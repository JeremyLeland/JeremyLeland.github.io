<style>
  body { margin: 0 }
  svg  { width: 100%; height: 100% }
  .snake { stroke: black; stroke-width: 2; }
</style>

<body>
</body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script>
  const Settings = {
    GoalWeight: 0.5,
    AvoidWeight: 100,
    AvoidPower: 1,
    DrawForces: false,
  };

  const SVGNS = 'http://www.w3.org/2000/svg';

  const svg = document.createElementNS( SVGNS, 'svg' );
  document.body.appendChild( svg );

  class Snake {
    #x;
    #y;
    #angle = 0;
    #size = 10;
    #turnSpeed = 0.005;
    #tail = [];
    #length = 0;

    #avoidVector;

    #isAlive = true;

    goalX = 0;
    goalY = 0;
    goalAngle = 0;
    speed = 0.2;

    maxLength = 100;

    #color = `hsl( ${ Math.random() * 360 }deg, 50%, 50% )`;

    #bodySVG = document.createElementNS( SVGNS, 'path' );
    #forcesSVG = new Map();

    constructor( x, y, angle ) {
      this.#x = x;
      this.#y = y;
      this.#angle = angle;

      this.#tail.push( { x: x, y: y, angle: angle, length: 0 } );

      this.#bodySVG.setAttribute( 'class', 'snake' );
      this.#bodySVG.style.fill = this.#color;

      svg.appendChild( this.#bodySVG );
    }

    angleTo( other ) { return this.angleToPoint( other.#x, other.#y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.#y, x - this.#x ); }

    distanceTo( other ) { return this.distanceToPoint( other.#x, other.#y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.#x, y - this.#y ); }

    update( dt, others ) {
      if ( this.#isAlive ) {
        const vectors = this.#getVectors( others );

        if ( vectors.find( vector => vector.dist < this.#size ) ) {
          this.#isAlive = false;
        }
        else {
          const distToGoal = this.distanceToPoint( this.goalX, this.goalY );
          let angX = Settings.GoalWeight * ( this.goalX - this.#x ) / distToGoal;
          let angY = Settings.GoalWeight * ( this.goalY - this.#y ) / distToGoal;

          this.goalAngle = Math.atan2( angY, angX );

          this.#turnTowardGoal( dt );

          const moveDist = this.speed * dt;

          this.#x += Math.cos( this.#angle ) * moveDist;
          this.#y += Math.sin( this.#angle ) * moveDist;

          this.#tail.push( { x: this.#x, y: this.#y, angle: this.#angle, length: moveDist } );
          this.#length += moveDist;
        }
      }
      else {
        this.maxLength -= this.speed * dt;
      }

      while ( this.#length > this.maxLength && this.#tail.length > 0 ) {
        this.#length -= this.#tail.shift().length;
      }

      this.#bodySVG.setAttribute( 'd', this.#getDString() );
    }

    #getVectors( others ) {
      const vectors = [];

      others.forEach( other => {

        const forceLines = [];

        other.#tail.forEach( ( segment, index, tail ) => {
          const cx = this.#x - segment.x;
          const cy = this.#y - segment.y;
          vectors.push( { 
            angle: Math.atan2( cy, cx ), 
            dist:  Math.hypot( cx, cy ) - other.#size * ( index / tail.length )
          } );

          forceLines.push( `M ${ this.#x },${ this.#y } L ${ this.#x + cx },${ this.#y + cy }` );
        } );

        if ( !this.#forcesSVG.has( other ) ) {
          const path = document.createElementNS( SVGNS, 'path' );
          path.style.stroke = other.#color;
          this.#forcesSVG.set( other, svg.appendChild( path ) );
        }
        const forcesPath = this.#forcesSVG.get( other );
        forcesPath.setAttribute( 'd', forceLines.join( ' ' ) );
      } );

      return vectors;
    }

    // TODO: Not just others -- need to check against ourselves, too! (as we get longer)
    #compareAgainstOthers( others ) {
      const DESIRED_SEPARATION = this.#size * 2;

      let angX = 0, angY = 0;
      others.forEach( other => {
        let avoidX = 0, avoidY = 0;
        other.#tail.forEach( segment => {
          const dist = this.distanceToPoint( segment.x, segment.y );

          if ( dist < this.#size + other.#size ) {
            this.#isAlive = false;
            this.#avoidVector = { x: 0, y: 0 };
            return;
          }

          // TODO: Account for segment width
          // for ( let i = 0; i < this.#tail.length; i ++ ) {
          //   const width = this.#size * i / this.#tail.length;

          const avoidWeight = Math.abs( Settings.AvoidWeight / Math.pow( dist - DESIRED_SEPARATION, Settings.AvoidPower ) );

          const cx = avoidWeight * ( this.#x - segment.x ) / dist;
          const cy = avoidWeight * ( this.#y - segment.y ) / dist;

          avoidX += cx / other.#tail.length;
          avoidY += cy / other.#tail.length;

        } );

        angX += avoidX / others.length;
        angY += avoidY / others.length;

      } );

      this.#avoidVector = { x: angX, y: angY };
    }

    #turnTowardGoal( dt ) {
      // Fix internal angle to better match goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    #getDString() {
      if ( this.#tail.length > 0 ) {
        const leftCoords = [], rightCoords = [];
        this.#tail.forEach( ( segment, index, tail ) => {
          const width = this.#size * index / tail.length;

          const leftAng = segment.angle - Math.PI / 2;
          const leftX = segment.x + Math.cos( leftAng ) * width;
          const leftY = segment.y + Math.sin( leftAng ) * width;
          leftCoords.push( `${ leftX },${ leftY }` );

          const rightAng = segment.angle + Math.PI / 2;
          const rightX = segment.x + Math.cos( rightAng ) * width;
          const rightY = segment.y + Math.sin( rightAng ) * width;
          rightCoords.unshift( `${ rightX },${ rightY }` );

        } );

        return `M ${ leftCoords.join( ' L ' ) } A ${ this.#size } ${ this.#size } 0 0 1 ${ rightCoords.join( ' L ' ) }`;
      }
      else {
        return '';
      }
    }
  }

  const snakes = Array.from( Array( 2 ), _ => 
    new Snake( 
      Math.random() * window.innerWidth, 
      Math.random() * window.innerHeight,
      Math.random() * Math.PI * 2
    ) 
  );

  // TEMP: Put a static obstacle to test against
  // const obstacle = new Snake( 100, 500 );
  // obstacle.goalX = 500;
  // obstacle.goalY = 500;
  // for ( let i = 0; i < 200; i ++ ) {
  //   obstacle.update( 10, snakes );
  // }
  // obstacle.speed = 0;

  // snakes.push( obstacle );

  // const gui = new dat.GUI();
  // gui.width = 200;
  // for ( const setting in Settings ) {
  //   gui.add( Settings, setting );
  // }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = onInput;
  document.ontouchstart = onInput;
  document.ontouchmove = onInput;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.pageX;
    mouseY = event.pageY;
  }

  let keyDown = true;     // default to running
  document.onkeydown = () => keyDown = true;
  document.onkeyup   = () => keyDown = false;

  function update( dt ) {
    snakes.forEach( snake => {
      snake.goalX = mouseX;
      snake.goalY = mouseY;
      snake.update( dt, snakes.filter( e => e != snake ) )
    } );
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only

    // Only update when key is pressed (for debugging purposes)
    if ( keyDown ) {
      update( now - lastTime );
    }
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>