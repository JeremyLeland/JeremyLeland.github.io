<style>
  body { margin: 0 }
  svg  { width: 100%; height: 100% }

  .snake { stroke: black; stroke-width: 2; }
  .apple { fill: red; stroke: black; stroke-width: 2; }

  .goalForce { stroke: gray; stroke-width: 2; }
  .avoidForce { stroke: black }
  .finalForce { stroke: green; stroke-width: 3; }
</style>

<body>
</body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script>
  const Settings = {
    GoalWeight: 0.5,
    AvoidWeight: 100,
    AvoidPower: 1,
    DrawForces: false,
  };

  const SVGNS = 'http://www.w3.org/2000/svg';

  const svg = document.createElementNS( SVGNS, 'svg' );
  document.body.appendChild( svg );

  class Snake {
    x;
    y;
    #angle = 0;
    #turnSpeed = 0.005;
    #tail = [];
    #length = 0;

    #avoidVector;

    isAlive = true;

    goalX = 0;
    goalY = 0;
    goalAngle = 0;
    speed = 0.2;
    size = 10;

    maxLength = 100;

    #color = `hsl( ${ Math.random() * 360 }deg, 50%, 50% )`;

    #bodySVG = document.createElementNS( SVGNS, 'path' );
    #goalForceSVG = document.createElementNS( SVGNS, 'path' );
    #avoidForcesSVG = document.createElementNS( SVGNS, 'path' );
    #finalForceSVG = document.createElementNS( SVGNS, 'path' );

    constructor( x, y, angle ) {
      this.x = x;
      this.y = y;
      this.#angle = angle;

      this.#tail.push( { x: x, y: y, angle: angle, length: 0 } );

      this.#bodySVG.setAttribute( 'class', 'snake' );
      this.#bodySVG.style.fill = this.#color;
      svg.appendChild( this.#bodySVG );

      this.#goalForceSVG.setAttribute( 'class', 'goalForce' );
      svg.appendChild( this.#goalForceSVG );

      this.#avoidForcesSVG.setAttribute( 'class', 'avoidForce' );
      svg.appendChild( this.#avoidForcesSVG );

      this.#finalForceSVG.setAttribute( 'class', 'finalForce' );
      svg.appendChild( this.#finalForceSVG );
    }

    isAlive() { return this.#tail.length > 0; }

    angleTo( other ) { return this.angleToPoint( other.x, other.y ); }
    angleToPoint( x, y ) { return Math.atan2( y - this.y, x - this.x ); }

    distanceTo( other ) { return this.distanceToPoint( other.x, other.y ); }
    distanceToPoint( x, y ) { return Math.hypot( x - this.x, y - this.y ); }

    // update( dt, others ) {
    //   if ( this.isAlive ) {
    //     const vectors = this.#getVectors( others );

    //     if ( vectors.find( vector => vector.dist < this.size ) ) {
    //       this.isAlive = false;
    //     }
    //     else {
          // const goalAngle = Math.atan2( this.goalY - this.y, this.goalX - this.x );

          // this.#goalForceSVG.setAttribute( 'd', this.#getForceLineDString( goalAngle, 1 ) );

          // let finalForce = vectors.reduce( ( acc, vector ) => ( { 
          //   x: acc.x + Math.cos( vector.angle ) * vector.weightedDist,// / vectors.length,
          //   y: acc.y + Math.sin( vector.angle ) * vector.weightedDist,// / vectors.length
          // } ), { x: this.goalX - this.x, y: this.goalY - this.y } );

          // const finalAngle = Math.atan2( finalForce.y, finalForce.x );

          // this.#finalForceSVG.setAttribute( 'd', this.#getForceLineDString( finalAngle, 1 ) );

          // this.turnTowardAngle( finalAngle, dt );

    //       const moveDist = this.speed * dt;

    //       this.x += Math.cos( this.#angle ) * moveDist;
    //       this.y += Math.sin( this.#angle ) * moveDist;

    //       this.#tail.push( { x: this.x, y: this.y, angle: this.#angle, length: moveDist } );
    //       this.#length += moveDist;
    //     }
    //   }
    //   else {
    //     this.maxLength -= this.speed * dt;
    //   }

    //   while ( this.#length > this.maxLength && this.#tail.length > 0 ) {
    //     this.#length -= this.#tail.shift().length;
    //   }

    //   this.#bodySVG.setAttribute( 'd', this.#getDString() );
    // }

    getVectors( snakes ) {
      const vectors = [];

      snakes.forEach( snake => {
        snake.#tail.forEach( ( segment, index, tail ) => {
          const cx = this.x - segment.x;
          const cy = this.y - segment.y;
          const angle = Math.atan2( cy, cx );
          const dist = Math.hypot( cx, cy ) - snake.size * ( index / tail.length ) - this.size;

          vectors.push( { 
            angle: angle,
            dist: dist,
          } );
        } );
      } );

      return vectors;
    }

    #getForceLineDString( angle, dist ) {
      const LENGTH = 50;
      const x2 = this.x + Math.cos( angle ) * dist * LENGTH;
      const y2 = this.y + Math.sin( angle ) * dist * LENGTH;
      return `M ${ this.x },${ this.y } L ${ x2 },${ y2 }`;
    }

    turnTowardAngle( goalAngle, dt ) {
      // Fix internal angle to better match goal angle
      if ( goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( goalAngle < this.#angle ) {
        this.#angle = Math.max( goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < goalAngle ) {
        this.#angle = Math.min( goalAngle, this.#angle + this.#turnSpeed * dt );
      }
    }

    checkCollisions( snakes ) {
      this.isAlive &= !snakes.some( snake => {
        return snake.#tail.some( ( segment, index, tail ) => {
          const width = snake.size * ( index / tail.length );
          return Math.hypot( this.x - segment.x, this.y - segment.y ) < this.size + width;
        } );
      } );
    }
    
    moveForward( dt ) {
      if ( this.isAlive ) {
        const moveDist = this.speed * dt;

        this.x += Math.cos( this.#angle ) * moveDist;
        this.y += Math.sin( this.#angle ) * moveDist;

        this.#tail.push( { x: this.x, y: this.y, angle: this.#angle, length: moveDist } );
        this.#length += moveDist;
      }
      else {
        this.maxLength -= this.speed * dt;
      }

      while ( this.#length > this.maxLength && this.#tail.length > 0 ) {
        this.#length -= this.#tail.shift().length;
      }

      this.#bodySVG.setAttribute( 'd', this.#getDString() );

      return this.#tail.length > 0;
    }

    drawGoalForce( goalForce ) {
      this.#goalForceSVG.setAttribute( 'd', 
        `M ${ this.x },${ this.y } L ${ this.x + goalForce.x * 100 },${ this.y + goalForce.y * 100 }`
      );
    }

    drawFinalForce( finalForce ) {
      this.#finalForceSVG.setAttribute( 'd', 
        `M ${ this.x },${ this.y } L ${ this.x + finalForce.x * 100 },${ this.y + finalForce.y * 100 }`
      );
    }

    drawAvoidForces( avoidForces ) {
      const len = 100 * avoidForces.length;
      this.#avoidForcesSVG.setAttribute( 'd', 
        avoidForces.map( wv => 
          `M ${ this.x },${ this.y } L ${ this.x + wv.x * len },${ this.y + wv.y * len }`
        ).join( ' ' )
      );
    }

    #getDString() {
      if ( this.#tail.length > 0 ) {
        const leftCoords = [], rightCoords = [];
        this.#tail.forEach( ( segment, index, tail ) => {
          const width = this.size * index / tail.length;

          const leftAng = segment.angle - Math.PI / 2;
          const leftX = segment.x + Math.cos( leftAng ) * width;
          const leftY = segment.y + Math.sin( leftAng ) * width;
          leftCoords.push( `${ leftX },${ leftY }` );

          const rightAng = segment.angle + Math.PI / 2;
          const rightX = segment.x + Math.cos( rightAng ) * width;
          const rightY = segment.y + Math.sin( rightAng ) * width;
          rightCoords.unshift( `${ rightX },${ rightY }` );

        } );

        return `M ${ leftCoords.join( ' L ' ) } A ${ this.size } ${ this.size } 0 0 1 ${ rightCoords.join( ' L ' ) }`;
      }
      else {
        return '';
      }
    }
  }

  class Apple {
    x;
    y;
    size = 10;
    svg = document.createElementNS( SVGNS, 'circle' );

    constructor( x, y ) {
      this.x = x;
      this.y = y;

      this.svg.setAttribute( 'class', 'apple' );
      this.svg.setAttribute( 'cx', x );
      this.svg.setAttribute( 'cy', y );
      this.svg.setAttribute( 'r', this.size );
      svg.appendChild( this.svg );
    }
  }

  let player = randomSnake();
  let snakes = [ player, randomSnake(), randomSnake() ];
  let apples = [];

  function randomSnake() {
    return new Snake( 
      Math.random() * window.innerWidth, 
      Math.random() * window.innerHeight,
      Math.random() * Math.PI * 2
    );
  }

  function spawnApple() {
    apples.push(
      new Apple( 
        Math.random() * window.innerWidth, 
        Math.random() * window.innerHeight,
      ) 
    );
  }

  spawnApple();
  spawnApple();
  spawnApple();
  setInterval( spawnApple, 5000 );

  function update( dt ) {
    snakes.forEach( snake => {
      apples = apples.filter( apple => {
        if ( snake.distanceTo( apple ) < snake.size + apple.size ) {
          snake.maxLength += 100;
          apple.svg.remove();
          return false;
        }

        return true;
      } );

      // TODO: Check ourselves as well, but avoid head
      const vectors = snake.getVectors( snakes.filter( e => e != snake ) );

      snake.isAlive &= vectors.every( vector => vector.dist > 0 );

      if ( snake == player ) {
        const towardMouse = Math.atan2( mouseY - snake.y, mouseX - snake.x );
        snake.turnTowardAngle( towardMouse, dt );
      }
      else {
        // Head toward closest apple
        // TODO: Use a waypoint to line up on it? (otherwise we sometimes circle them)
        let closest = apples.map( 
          apple => ( { apple: apple, dist: snake.distanceTo( apple ) } )
        ).reduce( 
          ( acc, appleDist ) => appleDist.dist < acc.dist ? appleDist : acc,
          { apple: null, dist: Infinity }
        );

        // TODO: Where to go if no apple? Waypoints system from above might help
        const goalX = closest.apple?.x ?? 0;  //Math.random() * window.innerWidth;
        const goalY = closest.apple?.y ?? 0;  //Math.random() * window.innerHeight;

        // Try to avoid other snakes
        const weighted = vectors.map( vector => {
          const weightedDist = Math.abs( Settings.AvoidWeight / Math.pow( vector.dist, Settings.AvoidPower ) );
          return { 
            x: Math.cos( vector.angle ) * weightedDist / vectors.length,
            y: Math.sin( vector.angle ) * weightedDist / vectors.length
          };
        } );

        snake.drawAvoidForces( weighted );

        const goalAngle = Math.atan2( goalY - snake.y, goalX - snake.x );
        const goalForce = {
          x: Settings.GoalWeight * Math.cos( goalAngle ), 
          y: Settings.GoalWeight * Math.sin( goalAngle ),
        }

        snake.drawGoalForce( goalForce );

        const finalForce = weighted.reduce(
          ( acc, wv ) => ( { x: acc.x + wv.x, y: acc.y + wv.y } ),
          goalForce
        );
        snake.drawFinalForce( finalForce );

        const finalAngle = Math.atan2( finalForce.y, finalForce.x );
        snake.turnTowardAngle( finalAngle, dt );
      }
    } );

    snakes = snakes.filter( snake => snake.moveForward( dt ) );
  }


  // const gui = new dat.GUI();
  // gui.width = 200;
  // for ( const setting in Settings ) {
  //   gui.add( Settings, setting );
  // }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = onInput;
  document.ontouchstart = onInput;
  document.ontouchmove = onInput;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.pageX;
    mouseY = event.pageY;
  }

  let keyDown = true;     // default to running
  document.onkeydown = () => keyDown = true;
  document.onkeyup   = () => keyDown = false;

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only

    // Only update when key is pressed (for debugging purposes)
    if ( keyDown ) {
      update( now - lastTime );
    }
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>