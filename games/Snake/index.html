<style>
  .border {
    width: 100%;
    height: 100%;
    stroke: black;
    stroke-linecap: round;
  }
</style>

<body>

</body>

<script>
  const XMLNS = 'http://www.w3.org/2000/svg';

  class Snake {
    #x;
    #y;
    #angle;
    #width;
    #speed;
    #points;
    #lines;
    #outlineSVG;

    goalAngle;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
      this.#angle = 0;
      this.#width = 20;
      this.#speed = 0.1;
      this.#points = [];
      this.#lines = [];

      this.#outlineSVG = document.createElementNS( XMLNS, 'svg' );
      this.#outlineSVG.setAttribute( 'class', 'border' );
      document.body.appendChild( this.#outlineSVG );

      // this.#colorSVG   = document.createElementNS( XMLNS, 'svg' );

      this.goalAngle = 0;
    }

    update( dt ) {
      if ( this.#points.unshift( { x: this.#x, y: this.#y } ) > 20 ) {
        this.#points.pop();
      }

      this.#x += Math.cos( this.#angle ) * this.#speed * dt;
      this.#y += Math.sin( this.#angle ) * this.#speed * dt;

      const line = document.createElementNS( XMLNS, 'line' );
      line.setAttribute( 'x1', this.#x );
      line.setAttribute( 'y1', this.#y );
      line.setAttribute( 'x2', this.#points[ 0 ].x );
      line.setAttribute( 'y2', this.#points[ 0 ].y );

      if ( this.#lines.unshift( line ) > 20 ) {
        this.#outlineSVG.removeChild( this.#lines.pop() );
      }
      this.#outlineSVG.appendChild( line );

      // Update widths
      const deltaWidth = this.#width / this.#lines.length;
      for ( let i = 0, width = this.#width; i < this.#lines.length; i ++, width -= deltaWidth ) {
        this.#lines[ i ].style.strokeWidth = width;
      }
    }
  }

  const size = 20;

  const points = [];

  let x = 32, y = 32, angle = 0;
  const speed = 7;

  for ( let i = 0; i < 20; i ++ ) {
    x += Math.cos( angle ) * speed;
    y += Math.sin( angle ) * speed;
    angle += 0.1;

    points.push( { x: x, y: y, angle: angle } );
  }

  const svg = document.createElementNS( XMLNS, 'svg' );
  svg.setAttribute( 'class', 'border' );
  document.body.appendChild( svg );

  const leftCoords = [], rightCoords = [];
  for ( let i = 0; i < points.length; i ++ ) {
    const width = size * i / ( points.length - 1 );

    const leftAng = points[ i ].angle - Math.PI / 2;
    const leftX = points[ i ].x + Math.cos( leftAng ) * width;
    const leftY = points[ i ].y + Math.sin( leftAng ) * width;
    leftCoords.push( `${ leftX } ${ leftY }` );

    const rightAng = points[ i ].angle + Math.PI / 2;
    const rightX = points[ i ].x + Math.cos( rightAng ) * width;
    const rightY = points[ i ].y + Math.sin( rightAng ) * width;
    rightCoords.unshift( `${ rightX } ${ rightY }` );
  }

  const dStr = `M ${ leftCoords.join( 'L' ) } A ${ size } ${ size } 0 0 1 ${ rightCoords.join( 'L' ) }`;

  const path = document.createElementNS( XMLNS, 'path' );
  path.setAttribute( 'd', dStr );
  svg.appendChild( path );


  // const snake = new Snake( 32, 32 );

  // function update( dt ) {
  //   snake.update( dt );
  // }

  // let lastTime = null;
  // function animate( now ) {
  //   lastTime ??= now;   // for first call only
  //   update( now - lastTime );
  //   lastTime = now;

  //   requestAnimationFrame( animate );
  // }
  // requestAnimationFrame( animate );

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
  }

</script>