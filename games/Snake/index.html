<style>
  .snake {
    stroke: black;
    fill: lightsalmon;
    stroke-linecap: round;
  }
</style>

<body>

</body>

<script>
  const XMLNS = 'http://www.w3.org/2000/svg';

  const svg = document.createElementNS( XMLNS, 'svg' );
  svg.style.width = '100%';
  svg.style.height = '100%';
  document.body.appendChild( svg );

  class Snake {
    #x;
    #y;
    #angle = 0;
    goalAngle = 0;
    #size = 10;
    #speed = 0.2;
    #turnSpeed = 0.005;
    #points = [];
    #svg;

    constructor( x, y ) {
      this.#x = x;
      this.#y = y;
      this.#points.push( { x: this.#x, y: this.#y, angle: this.#angle } );

      this.#svg = document.createElementNS( XMLNS, 'path' );
      this.#svg.setAttribute( 'class', 'snake' );

      svg.appendChild( this.#svg );
    }

    aimToward( x, y ) {
      this.goalAngle = Math.atan2( y - this.#y, x - this.#x );
    }

    update( dt ) {
      // Fix goal angle
      if ( this.goalAngle - this.#angle > Math.PI ) {
        this.#angle += Math.PI * 2;
      }
      else if ( this.#angle - this.goalAngle > Math.PI ) {
        this.#angle -= Math.PI * 2;
      }

      // Turn toward goal angle
      if ( this.goalAngle < this.#angle ) {
        this.#angle = Math.max( this.goalAngle, this.#angle - this.#turnSpeed * dt );
      }
      else if ( this.#angle < this.goalAngle ) {
        this.#angle = Math.min( this.goalAngle, this.#angle + this.#turnSpeed * dt );
      }

      this.#x += Math.cos( this.#angle ) * this.#speed * dt;
      this.#y += Math.sin( this.#angle ) * this.#speed * dt;

      if ( this.#points.push( { x: this.#x, y: this.#y, angle: this.#angle } ) > 20 ) {
        this.#points.shift();
      }

      this.#svg.setAttribute( 'd', this.getDString() );
    }

    // TODO: Draw this to canvas instead of using path object?
    //       Start with arc( x, y, angle - PI/2, angle + PI/2 ) as head,
    //       so we can use the points as the tail and only have one push up top?

    getDString() {
      const leftCoords = [], rightCoords = [];
      for ( let i = 0; i < this.#points.length; i ++ ) {
        const width = this.#size * i / ( this.#points.length - 1 );

        const leftAng = this.#points[ i ].angle - Math.PI / 2;
        const leftX = this.#points[ i ].x + Math.cos( leftAng ) * width;
        const leftY = this.#points[ i ].y + Math.sin( leftAng ) * width;
        leftCoords.push( `${ leftX },${ leftY }` );

        const rightAng = this.#points[ i ].angle + Math.PI / 2;
        const rightX = this.#points[ i ].x + Math.cos( rightAng ) * width;
        const rightY = this.#points[ i ].y + Math.sin( rightAng ) * width;
        rightCoords.unshift( `${ rightX },${ rightY }` );
      }

      return `M ${ leftCoords.join( ' L ' ) } A ${ this.#size } ${ this.#size } 0 0 1 ${ rightCoords.join( ' L ' ) }`;
    }
  }

  const snake = new Snake( 32, 32 );

  let mouseX = 0, mouseY = 0;
  document.onmousemove = ( e ) => {
    mouseX = e.offsetX;
    mouseY = e.offsetY;
  }

  function update( dt ) {
    snake.aimToward( mouseX, mouseY );
    snake.update( dt );
  }

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only
    update( now - lastTime );
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>